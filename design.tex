\begin{chapter}{Design}
  Two sub-problems where identified during the design: simulating the behavior of Reaction Systems, RS processes and other operations on LTS, and interacting with the user in a intuitive manner. The programming language chosen was Rust\cite{rust_2025}, since it offered good performance and ease of development.
  Two Git repositories are provided: ReactionSystems\cite{ReactionSystemsGit} and ReactionSystemsGUI\cite{ReactionSystemsGUIGit}.

  The ReactionSystems project follows a modular architecture and clear design principles to mirror the theoretical model; it implements procedures over RS as pure rust functions and is structured as a library. It also provides a crude Command Line Interface for some of the functions provided.
  The code is organized in workspaces in order to reduce compilation time and aid code reuse.
  In the second Git repository a native and web application is implemented in Rust and in WebAssembly\cite{WebAssemblyCoreSpecification2} generated from Rust code. The web application consists of only static files and as such may be served by a simple HTTP server.

  In the signature of the functions, types will be displayed in teletype font. The decorator \({}^{?}\) will be used for both option types and for result types without distinction.

  \begin{section}{ReactionSystems}
    The design is structured to faithfully implement the reaction system formalism while remaining flexible.
    It provides a foundation that matches theoretical definitions (ensuring correctness) and supports further expansion (such as adding optimization, visualization, or integration with other tools) by maintaining a clean separation between the model representation and the execution logic.
    Since the language Rust supports object-oriented programming via traits, but lacks generic inheritance, the design of the basic building blocks of RSs are designed around this limitation.
    Usually a basic trait is provided for each of them and an extension of the trait is implemented for all structures that implement the basic trait.

    Since it is not practical for a user to specify the structures in Rust, a syntax for the basic structures has been specified. This syntax tries to remain as much as possible compatible with ones from previous software. To develop the parser, LALRPOP\cite{Burgener2025} was chosen as the parser generator framework. LALRPOP code is transpiled to Rust code via macros and then compiled to machine code.

    \begin{figure}[!h]
      \centering
      \begin{tikzpicture}[
        place/.style={rectangle,draw=blue!50,fill=blue!20,thick},
        >=Stealth, thick, every node/.style={font=\sffamily}]

        \node[place] (set)     at (0,3)      {Set};
        \node[place] (reaction)at (4,3)      {Reaction};
        \node[place] (choices) at (8,3)    {Choices};
        \node[place] (label)   at (-2,1.5) {Label};
        \node[place] (env)     at (2,1.5)  {Environment};
        \node[place] (process) at (6,1.5)  {Process};
        \node[place] (system)  at (4,0)    {System};
        \node[place] (graph)   at (0,0)   {Graph};

        % Set
        \draw[->]              (set) -- (reaction);
        \draw[->,bend left=18] (set) to (choices);
        \draw[->,bend right=25](set) to (label);
        \draw[->]              (set) -- (graph);
        \draw[->,bend right=35,looseness=1.1] (set) to (system);
        \draw[->,bend right=12](set) to (env);

        % Label -> Graph
        \draw[->] (label) -- (graph);

        % Reaction
        \draw[->,bend left=12]  (reaction) to (process);
        \draw[->,bend right=12] (reaction) to (env);
        \draw[->,bend left=16]  (reaction) to (system);

        % Process
        \draw[->]               (process) -- (env);
        \draw[->]               (process) -- (system);
        \draw[->,bend right=18] (process) to (choices);

        \draw[->] (choices) to [bend left=2] (env);
        \draw[->] (choices.south) to [bend left=25] (system.east);
        \draw[->]               (env) -- (system);
        \draw[<->,bend left=15] (system) to (graph);
      \end{tikzpicture}
      \caption{Basic structures and relationships between them}\label{basic_structures}
    \end{figure}

    \begin{subsection}{Entities and Translator}\label{design_entities}
      Entities are the most basic data structure that a RS need to keep track of. They don't have a specified interface and are instead treated only in sets.

      Positive elements are also defined and have a state, either \texttt{Positive} or \texttt{Negative}.

      Since internally entities are represented as integers, a structure that keeps track of assignment between strings and integer is provided (\(\texttt{Translator}\)). This poses a problem with the default methods for formatting available in Rust, since for the trait \(\texttt{Display}\) and \(\texttt{Debug}\) only the structure itself can be used to generate the string. The trait \(\texttt{PrintableWithTranslator}\) and the structure \(\texttt{Formatter}\) solve this issue by incorporating the \(\texttt{Translator}\) into the struct. \(\texttt{Display}\) is then implemented on the generic structure \(\texttt{Translator}\).
    \end{subsection}

    \begin{subsection}{Set}\label{design_set}
      The common procedures required for all sets are:
      \begin{itemize}
      \item \(\texttt{is\_subset}(a, b) \to \texttt{bool}\), which should return true if \(a \subseteq b\);
      \item \(\texttt{is\_disjoint}(a, b) \to \texttt{bool}\), which should return true if \(a \cap b = \emptyset\);
      \item \(\texttt{union}(a, b) \to \texttt{set}\), which should return \(a \cup b\);
      \item \(\texttt{push}(a, b)\), which should replace \(a\) with \(a \cup b\) in place\label{push_set};
      \item \(\texttt{intersection}(a, b) \to \texttt{set}\), which should return \(a \cap b\);
      \item \(\texttt{subtraction}(a, b) \to \texttt{set}\), which should return \(a \setminus b\);
      \item \(\texttt{len}(a) \to \texttt{int}\), which should return the number of elements in \(a\);
      \item \(\texttt{is\_empty}(a) \to \texttt{bool}\), which should return true if \(a\) has no elements, false otherwise;
      \item \(\texttt{contains}(a, e: \texttt{entity}) \to \texttt{bool}\), which should return \(e \in a\);
      \item \(\texttt{add}(a, e: \texttt{element})\), which should add the element \(e\) to \(a\) in place.
      \end{itemize}

      Some other procedures are required for ease of use:
      \begin{itemize}
      \item \(\texttt{extend}(a, b^?)\), which should extend \(a\) with \(a \cup b\) if \(b\) is a non-null value, and leave \(a\) unchanged otherwise, similar to \(\texttt{push}\) (\ref{push_set}).
      \end{itemize}

      Two other procedures are implemented for all structs that implement the BasicSet trait:
      \begin{itemize}
      \item \(\texttt{iter}(a) \to \texttt{iterable}\), which returns an iterator over the elements of the set \(a\);
      \item \(\texttt{split}(a, \mathit{trace}: \texttt{[set]}) \to {(\texttt{[set]}, \texttt{[set]})}^{?}\), which returns the prefix and the loop part of a trace.
      \end{itemize}

      Both normal sets and positive sets satisfy this interface, but have additional specific functions for converting between the two.

      The syntax for sets is:

      \begin{minipage}{\textwidth}
        \centering
        \begin{minipage}[b][][b]{.38\textwidth}
          \centering
          \begin{bnf}(relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Set$ : ::= % chktex 26
            | $\texttt{\{} S \texttt{\}}$ : % chktex 26
            ;; % chktex 26
            $S$ : ::= % chktex 26
            | $s\ \texttt{,}\ S$ : % chktex 26
            | $s$ : % chktex 26
            | $\epsilon$ : % chktex 26
            ;; % chktex 26
            Where \\ & \(s\) -> is a string : % chktex 26
            ;; % chktex 26
            $\epsilon$ -> is the empty string : % chktex 26
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Set}\label{bnf_set}
        \end{minipage}%
        \begin{minipage}[b][][b]{.58\textwidth}
          \centering
          \begin{bnf}(relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            {\small $PositiveSet$} : ::= % chktex 26
            | $\texttt{\{} S \texttt{\}}$ : % chktex 26
            ;; % chktex 26
            $S$ : ::= % chktex 26
            | $\mathit{state}\ s\ \texttt{,}\ S$ : % chktex 26
            | $\mathit{state}\ s$ : % chktex 26
            | $\epsilon$ : % chktex 26
            ;; % chktex 26
            $state$ : ::= % chktex 26
            | $\texttt{+}$ : % chktex 26
            | $\texttt{-}$ : % chktex 26
            ;; % chktex 26
            Where \\ & \(s\) -> is a string : % chktex 26
            ;; % chktex 26
            $\epsilon$ -> is the empty string : % chktex 26
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Positive Set}\label{bnf_positive_set}
        \end{minipage}
      \end{minipage}
    \end{subsection}


    \begin{subsection}{Reaction}\label{design_reaction}
      The methods required for all reactions are:

      \begin{itemize}
      \item \(\texttt{enabled}(r, \mathit{state}: \texttt{set}) \to \texttt{bool}\), which returns true if the reaction is enabled given the entities supplied by \(\mathit{state}\);
      \item \(\texttt{compute\_step}(r, \mathit{state}: \texttt{set}) \to \texttt{set}^{?}\), which returns the products of the reaction if it is enabled by \(\mathit{state}\).
      \end{itemize}

      All reactions that satisfy the basic trait automatically implement the following methods:
      \begin{itemize}
      \item \(\texttt{find\_loop}(\mathit{rs}: \texttt{[reaction]}, \mathit{entities}: \texttt{set}, q: \texttt{set}) \to \texttt{([set], [set])}\), which finds a loop and returns the sets that make up the prefix and the loop separately;
      \item \(\texttt{find\_only\_loop}(\mathit{rs}: \texttt{[reaction]}, \mathit{entities}: \texttt{set}, q: \texttt{set}) \to \texttt{[set]}\), which finds a loop and returns the sets that form it;
      \item \(\texttt{find\_prefix\_len\_loop}(\mathit{rs}: \texttt{[reaction]}, \mathit{entities}: \texttt{set}, q: \texttt{set}) \to \texttt{(integer, [set])}\), which finds a loop and returns the length of the prefix and the sequence of sets that compose the loop;
      \end{itemize}

      \begin{minipage}{\textwidth}
        \centering
        \begin{minipage}{\textwidth}
          \centering
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Reaction$ == ::= % chktex 26
            | $\texttt{[} s \texttt{,}\  s \texttt{,}\  s \texttt{]}$ == % chktex 26 chktex 9
            | $\texttt{[r:}\ s \texttt{, i:}\ s \texttt{, p:}\ s \texttt{]}$ == % chktex 26 chktex 9
            ;; % chktex 26
            Where \\ & \(s\) -> {is a set, see\ \ref{bnf_set}} == % chktex 26
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Reaction}\label{bnf_reaction}
        \end{minipage}\vspace{2em}

        \begin{minipage}{\textwidth}
          \centering
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $PositiveReaction$ == ::= % chktex 26
            | $\texttt{[} s \texttt{,}\  s \texttt{,}\  s \texttt{]}$ == % chktex 26 chktex 9
            | $\texttt{[r:}\ s \texttt{, i:}\ s \texttt{, p:}\ s \texttt{]}$ == % chktex 26 chktex 9
            ;; % chktex 26
            Where \\ & \(s\) -> {is a positive set, see\ \ref{bnf_positive_set}} == % chktex 26
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Positive Reaction}\label{bnf_positive_reaction}
        \end{minipage}
      \end{minipage}
    \end{subsection}


    \begin{subsection}{Process}\label{design_process}
      Process structures mirror the structure of RS processes as described in Section\ \ref{SOS_rules_section}. Since there is not much behavior that is shared between implementations and since usually they are used with pattern matching, the trait that describe a basic process is very simple.
      \begin{itemize}
      \item \(\texttt{concat}(a, b) \to \texttt{process}\), which returns a new process \(a \vert b\) flattened with regards to parallel composition;
      \item \(\texttt{all\_elements}(a) \to \texttt{set}\), which returns all the entities used in the process;
      \item \(\texttt{filter\_delta}(a, \mathit{id}: \texttt{entity}) \to \texttt{set}^{?}\), which returns the first rule \(X = Q. rec(X)\) for any symbol \(X\).
      \end{itemize}

      \begin{minipage}{\textwidth}
        \begin{minipage}[b][][b]{.48\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Process$ == ::= % chktex 26
            | $\texttt{[} P \texttt{]}$ == % chktex 9
            ;; % chktex 26
            $P$ == ::= % chktex 26
            | $ C \texttt{,} P $ ==
            | $ C $ ==
            ;; % chktex 26
            $C$ == ::= % chktex 26
            | $ \texttt{(} C \texttt{)} $ == % chktex 9 chktex 10
            | $ \texttt{nill} $ ==
            | $ s \texttt{.} C $ ==
            | $ C \texttt{+} C $ ==
            | $ \texttt{?} r \texttt{?.} C $ ==
            | $ \texttt{<} i \texttt{,} C \texttt{>.} C $ ==
            | $ x $ ==
            ;; % chktex 26
            Where \\ & \(s\) -> {is a set,\\ see\ \ref{bnf_set}} ==
            ;; % chktex 26
            \(r\) -> {is a reaction,\\ see\ \ref{bnf_reaction}} ==
            ;; % chktex 26
            \(i\) :in: \(\mathbb{N}\) == % chktex 26
            ;; % chktex 26
            \(x\) -> is a variable name ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Process}\label{bnf_process}
        \end{minipage}
        \begin{minipage}[b][][b]{.48\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $PositiveP$ == ::= % chktex 26
            | $\texttt{[} P \texttt{]}$ == % chktex 9
            ;; % chktex 26
            $P$ == ::= % chktex 26
            | $ C \texttt{,} P $ ==
            | $ C $ ==
            ;; % chktex 26
            $C$ == ::= % chktex 26
            | $ \texttt{(} C \texttt{)} $ == % chktex 9 chktex 10
            | $ \texttt{nill} $ ==
            | $ ps \texttt{.} C $ ==
            | $ C \texttt{+} C $ ==
            | $ \texttt{?} pr \texttt{?.} C $ ==
            | $ \texttt{<} i \texttt{,} C \texttt{>.} C $ ==
            | $ x $ ==
            ;; % chktex 26
            Where \\ & \(ps\) -> {is a positive set,\\ see\ \ref{bnf_positive_set}} ==
            ;; % chktex 26
            \(pr\) -> {is a positive reaction,\\ see\ \ref{bnf_positive_reaction}} ==
            ;; % chktex 26
            \(i\) :in: \(\mathbb{N}\) == % chktex 26
            ;; % chktex 26
            \(x\) -> is a variable name ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Positive Process}\label{bnf_positive_process}
        \end{minipage}
      \end{minipage}
    \end{subsection}


    \begin{subsection}{Choices}
      Since one RS process may have more than one possible next system when evaluating, there is a need to express all possible choices for next states.
      The structure choices represents all those possible continuations, associating a set with a process. The set signifies all the entities that are provided by the context by choosing that context.
      One particular operation called \texttt{shuffle} is needed: given two choices structures \( c_1 \) and \( c_2 \) where \(c_i : \texttt{set} \rightharpoonup \texttt{process}, i \in \{1, 2\}\), it generates a new choices structure \(c'\) such that \(\forall s_1 \in \mathit{domain}(c_1) . (\forall s_2 \in \mathit{domain}(c_2) . \mathit{domain}(c') \ni (s_1 \cup s_2) \land c'(s_1 \cup s_2) = \texttt{concat}(c_1(s_1), c_2(s_2)) ) \). Intuitively it is all the possible combinations of two parallel processes.
    \end{subsection}


    \begin{subsection}{Environment}\label{design_environment}
      An environment can be thought as an association between variable names and processes.
      The basic interface requires the following methods:

      \begin{itemize}
      \item \(\texttt{get}(a, k: \texttt{entity}) \to \texttt{process}\), which returns the process associated with the variable \(k\);
      \item \(\texttt{all\_elements}(a) \to \texttt{set}\), which returns all the entities used in any of the processes;
      \item \(\texttt{unfold}(a, \mathit{context}: \texttt{process}, \mathit{s}: \texttt{set}) \to \texttt{choices}^{?}\), which returns the list of choices for the context, given the process definitions environment and is used to generate the next systems with the SOS rules.
      \end{itemize}

      These methods are automatically implemented for all \(\texttt{BasicEnvironment}\):
      \begin{itemize}
      \item \(\texttt{lollipops\_decomposed}\),
      \item \(\texttt{lollipops\_decomposed\_named}\),
      \item \(\texttt{lollipops\_prefix\_len\_loop\_decomposed}\),
      \item \(\texttt{lollipops\_prefix\_len\_loop\_decomposed\_named}\),
      \item \(\texttt{lollipops\_only\_loop\_decomposed}\),
      \item \(\texttt{lollipops\_only\_loop\_decomposed\_named}\).
      \end{itemize}
      They all try to find a loop and return some information about the found loop. The \(\texttt{\_named}\) variants require a variable symbol for which in the environment there is an association to a process with the form \( X = Q.\texttt{rec}(X) = Q.X\), where \(Q\) is a set and \(X\) is a variable name. The others instead finds all the symbols that satisfy the constraint and uses them all.
      Function \(\texttt{lollipops\_decomposed}\) returns the trace of sets for the prefix and the trace of sets for the loop for each recursive variable.\\
      \(\texttt{lollipops\_prefix\_len\_loop\_decomposed}\) returns the length of the prefix and the trace of the loop for each recursive variable.
      \(\texttt{lollipops\_only\_loop\_decomposed}\) returns the trace of the loop for each recursive variable.\vspace{1em}

      \begin{minipage}{\textwidth}
        \centering
        \begin{minipage}{.9\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Environment$ == ::= % chktex 26
            | $\texttt{[} E \texttt{]}$ == % chktex 9
            ;; % chktex 26
            $E$ == ::= % chktex 26
            | $ x = c \texttt{,} E $ ==
            | $ x = c $ ==
            | $ \epsilon $ ==
            ;; % chktex 26
            Where \\ & \(c\) -> {is a process, see\ \ref{bnf_process}} ==
            ;; % chktex 26
            \(x\) -> is a variable name ==
            ;; % chktex 26
            \(\epsilon\) -> is the empty string ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Environment}\label{bnf_environment}
        \end{minipage}\vspace{1em}

        \begin{minipage}{.9\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Positive Environment$ == ::= % chktex 26
            | $\texttt{[} E \texttt{]}$ == % chktex 9
            ;; % chktex 26
            $E$ == ::= % chktex 26
            | $ x = pc \texttt{,} E $ ==
            | $ x = pc $ ==
            | $ \epsilon $ ==
            ;; % chktex 26
            Where \\ & \(pc\) -> {is a positive process, see\ \ref{bnf_positive_process}} ==
            ;; % chktex 26
            \(x\) -> is a variable name ==
            ;; % chktex 26
            \(\epsilon\) -> is the empty string ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Positive Environment}\label{bnf_positive_environment}
        \end{minipage}
      \end{minipage}
    \end{subsection}


    \begin{subsection}{System}\label{design_system}
      The basic interface for systems is only the following methods:

      \begin{itemize}
      \item \(\texttt{to\_transitions\_iterator}(sys) \to \texttt{iterator}\text{ that yields }\texttt{(label, system)}\)
      \item \(\texttt{to\_slicing\_iterator}(sys) \to \texttt{iterator}\text{ that yields }\\\hspace*{0pt}\hfill \texttt{(set, set, [int], system)}\)
      \item \(\texttt{context\_elements}(sys) \to \texttt{set}\)
      \item \(\texttt{products\_elements}(sys) \to \texttt{set}\)
      \end{itemize}

      The method \(\texttt{to\_transitions\_iterator}\) should return an iterator over all the possible evaluations of the system. Likewise \(\texttt{to\_slicing\_iterator}\) should return an iterator over the same outgoing edges, but with information that support the creation of a trace to be used for slicing.

      The two methods \(\texttt{context\_elements}\) and \(\texttt{products\_elements}\) should return the set of entities that are related to the context and the one related to the reactions. Since it may be a computationally expensive calculation, the result is cached in the structures.
      The heuristic that decides which elements belong to the context and which belong to the reactions might give incorrect results, so methods are provided that override the calculated values.

      Other methods are implemented for all structures that satisfy the previous interface:

      \begin{itemize}
      \item \(\texttt{unfold}(\mathit{sys}) \to \texttt{choices}^{?}\), which, by calling the same method of the environment, returns the list of choices for the context;
      \item \(\texttt{run}(\mathit{sys}) \to \texttt{[system]}^{?}\), which computes the sequence of systems for the leftmost execution;
      \item \(\texttt{digraph}(\mathit{sys}) \to \texttt{graph}^{?}\), which computes the graph generated by the execution of the system;
      \item \(\texttt{target}(\mathit{sys}) \to \texttt{(integer, set)}^{?}\), which returns the state in one of the terminal states and the number of steps to arrive at the last state;\label{function_target}
      \item \(\texttt{slice\_trace}(\mathit{sys}) \to \texttt{trace}^{?}\), which generates, similarly to \(\texttt{run}\), a trace appropriate to run slicing calculations over;
      \item \(\texttt{lollipops}(\mathit{sys}) \to \texttt{[([set], [set])]}\), similar to the method\\\(\texttt{lollipops\_decomposed}\) provided by \(\texttt{environment}\).
      \item \(\texttt{lollipops\_only\_loop\_named}(\mathit{sys}, el: \texttt{element}) \to \texttt{[[set]]}^{?}\), similar to the method provided by \(\texttt{environment}\), returns the sequence of entities in the loop individuated by the variable name \(el\) in the environment.
      \end{itemize}

      \begin{minipage}{\textwidth}
        \centering
        \begin{bnf} (relation = {::=|:in:|->},
          comment = {==},
          relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },)
          $System$ == ::= % chktex 26
          | {$\texttt{Environment:} e$ \\ $ \texttt{Initial Entities:} s$ \\ $ \texttt{Context:} c$ \\ $ \texttt{Reactions: (} R \texttt{)}$} == % chktex 26 chktex 9
          ;; % chktex 26
          $R$ == ::= % chktex 26
          | {$r \texttt{;} R$} ==
          | {$\epsilon$}
          ;; % chktex 26
          Where \\ & \(e\) -> {is an environment, see\ \ref{bnf_environment}} ==
          ;; % chktex 26
          \(s\) -> is a set, see\ \ref{bnf_set} ==
          ;; % chktex 26
          \(c\) -> is a Process, see\ \ref{bnf_process} ==
          ;; % chktex 26
          \(r\) -> is a reaction, see\ \ref{bnf_reaction} ==
          ;; % chktex 26
          \(\epsilon\) -> is the empty string
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for System}
      \end{minipage}

      While writing systems, occurs often to forget an element or swap elements names. This type of user error is particularly difficult to spot since most element names are not easily recognizable and the system grammar is particularly dense in information. A useful method to mitigate these problems is provided: \(\texttt{statistics}\). For the structure \(\texttt{System}\) a static analysis of the entities of the system is run and various parameters are checked and reported.
    \end{subsection}

    \begin{subsection}{Label}
      The label structure holds the information about how entities are used in the production of a system and are the labels on the edges of the graphs. Since the only use is to hold data, no meaningful method is required.\vspace{2em}

      \begin{minipage}{\textwidth}
        \centering
        \begin{minipage}{.9\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Label$ == ::= % chktex 26
            | {$\texttt{[Entities:} s\texttt{,}$\\$\texttt{Context:} s\texttt{,}$\\$\texttt{Reactants:} s\texttt{,}$\\$\texttt{ReactantsAbsent:} s\texttt{,}$\\$\texttt{Inhibitors:} s\texttt{,}$\\$\texttt{InhibitorsPresent:} s\texttt{,}$\\$\texttt{Products:} s \texttt{]}$} == % chktex 9
            ;; % chktex 26
            Where \\ & \(s\) -> {is a set, see\ \ref{bnf_set}} ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Label}\label{bnf_label}
        \end{minipage}\vspace{1em}

        \begin{minipage}{.9\textwidth}
          \begin{bnf} (relation = {::=|:in:|->},
            comment = {==},
            relation-sym-map = % chktex 36
            {
              {::=} = {\ensuremath{\Coloneqq}},
              {->} = {},
              {:in:} = {\ensuremath{\in}},
            },)
            $Label$ == ::= % chktex 26
            | {$\texttt{[Entities:} ps\texttt{,}$\\$\texttt{Context:} ps\texttt{,}$\\$\texttt{Reactants:} ps\texttt{,}$\\$\texttt{ReactantsAbsent:} ps\texttt{,}$\\$\texttt{Inhibitors:} ps\texttt{,}$\\$\texttt{InhibitorsPresent:} ps\texttt{,}$\\$\texttt{Products:} ps \texttt{]}$} == % chktex 9
            ;; % chktex 26
            Where \\ & \(ps\) -> {is a positive set, see\ \ref{bnf_positive_set}} ==
            ;; % chktex 26
          \end{bnf}
          \captionsetup{type=table, name=\textbf{Syntax}}
          \caption{Syntax for Positive Environment}\label{bnf_positive_label}
        \end{minipage}
      \end{minipage}
    \end{subsection}

    \begin{subsection}{Graph}\label{design_graph}
      The project uses petgraph\cite{Borgna2025} as graph data structure library. \textit{petgraph} provides several graph types, but the only one used is \(\texttt{Graph}\), since it provided the best performance during testing. The library has methods for converting the graph structures into {Dot Language}\cite{graphviz_2025} and {GraphML File Format}\cite{graphml_2025}. The Dot methods where found to be not powerful enough and where partially rewritten in the file \href{https://github.com/elvisrossi/ReactionSystems/blob/master/rsprocess/src/dot.rs}{\(\texttt{dot.rs}\)}.

      Custom formatting of the graphs was a key requirement, so domain specific languages are provided to customize the appearance of the generated formats.
      Four structures are provided:

      \begin{itemize}
      \item \(\texttt{NodeDisplay}\), to specify the text displayed on each node;
      \item \(\texttt{EdgeDisplay}\), to specify the text displayed on each edge;
      \item \(\texttt{NodeColor}\), to specify the color of each node;
      \item \(\texttt{EdgeColor}\), to specify the color of each edge.
      \end{itemize}

      Follows the BNF for each of the languages:\vspace{2em}

      \begin{minipage}{\textwidth}
        \centering
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },)
          $NodeDisplay$ : ::= % chktex 26
          | $E$ : % chktex 26
          | $E\ \texttt{"}\mathit{s}\texttt{"}\ NodeDisplay$ : % chktex 26 chktex 18
          ;; % chktex 26
          $E$ : ::= % chktex 26
          | $\texttt{Hide}$ : % chktex 26
          | $\texttt{Entities}$ : % chktex 26
          | $\texttt{MaskEntities}\ S$ : % chktex 26
          | $\texttt{ExcludeEntities}\ S$ : % chktex 26
          | $\texttt{Context}$ : % chktex 26
          | $\texttt{UncommonEntities}$ : % chktex 26
          | $\texttt{MaskUncommonEntities}\ S$ : % chktex 26
          ;; % chktex 26
          Where \\ & \(S\) -> is a sets of entities : % chktex 26
          ;; % chktex 26
          \(s\) -> is a possibly empty string : % chktex 26
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for \(\texttt{NodeDisplay}\)}\label{bnf_node_display}
      \end{minipage}\vspace{1em}

      $\texttt{Hide}$ ignores the content of the node and prints the empty string, $\texttt{Entities}$ prints the list of entities currently available in the system,  $\texttt{MaskEntities}\ S$ prints the list of entities masked by a specified set \(S\), $\texttt{ExcludeEntities}\ S$ prints the list of entities except for the entities specified by the set \(S\), $\texttt{Context}$ prints the context of the system, $\texttt{UncommonEntities}$ prints only the entities that are not shared between all the nodes in the graph, $\texttt{MaskUncommonEntities}\ S$ prints the entities not shared between all the nodes in the graph and masked by a specified set \(S\).

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },)
          $EdgeDisplay$ : ::= % chktex 26
          | $E$ : % chktex 26
          | $E\ \texttt{"}\mathit{s}\texttt{"}\ EdgeDisplay$ : % chktex 26 chktex 18
          ;; % chktex 26
          $E$ : ::= % chktex 26
          | $\texttt{Hide}$ : % chktex 26
          | $\texttt{Products}$ : % chktex 26
          | $\texttt{MaskProducts}\ S$ : % chktex 26
          | $\texttt{UncommonProducts}$ : % chktex 26
          | $\texttt{UncommonMaskProducts}\ S$ : % chktex 26
          | $\texttt{Entities}$ : % chktex 26
          | $\texttt{MaskEntities}\ S$ : % chktex 26
          | $\texttt{UncommonEntities}$ : % chktex 26
          | $\texttt{UncommonMaskEntities}\ S$ : % chktex 26
          | $\texttt{Context}$ : % chktex 26
          | $\texttt{MaskContext}\ S$ : % chktex 26
          | $\texttt{UncommonContext}$ : % chktex 26
          | $\texttt{UncommonMaskContext}\ S$ : % chktex 26
          | $\texttt{Union}$ : % chktex 26
          | $\texttt{MaskUnion}\ S$ : % chktex 26
          | $\texttt{UncommonUnion}$ : % chktex 26
          | $\texttt{UncommonMaskUnion}\ S$ : % chktex 26
          | $\texttt{Difference}$ : % chktex 26
          | $\texttt{MaskDifference}\ S$ : % chktex 26
          | $\texttt{UncommonDifference}$ : % chktex 26
          | $\texttt{UncommonMaskDifference}\ S$ : % chktex 26
          | $\texttt{EntitiesDeleted}$ : % chktex 26
          | $\texttt{MaskEntitiesDeleted}\ S$ : % chktex 26
          | $\texttt{UncommonEntitiesDeleted}$ : % chktex 26
          | $\texttt{UncommonMaskEntitiesDeleted}\ S$ : % chktex 26
          | $\texttt{EntitiesAdded}$ : % chktex 26
          | $\texttt{MaskEntitiesAdded}\ S$ : % chktex 26
          | $\texttt{UncommonEntitiesAdded}$ : % chktex 26
          | $\texttt{UncommonMaskEntitiesAdded}\ S$ : % chktex 26
          ;; % chktex 26
          Where \\ & \(S\) -> is a sets of entities : % chktex 26
          ;; % chktex 26
          \(s\) -> is a possibly empty string : % chktex 26
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for \(\texttt{EdgeDisplay}\)}\label{bnf_edge_display}
      \end{minipage}\vspace{1em}

      Four version of each base option is available: normal, \(\texttt{Mask}\) which masks the normal set of entities with a specified set, \(\texttt{Uncommon}\) which considers only the entities that are not shared between all edges of the graph, and \(\texttt{UncommonMask}\) which combines the two functionalities. The base options return the corresponding entities available in the label.

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },)
          $NodeColor$ : ::= % chktex 26
          | $\texttt{!} \texttt{"}\ C\ \texttt{"}$ : % chktex 26 chktex 18
          | $E\ \texttt{\textbar}\texttt{\textbar}\ NodeColor$ : % chktex 26
          ;; % chktex 26
          $E$ : ::= % chktex 26
          | $\texttt{Entities}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context.Nill}\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context.RecursiveIdentifier}\ \texttt{(}\ x\ \texttt{)} \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18 chktex 9
          | $\texttt{Context.EntitySet}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context.NonDeterministicChoice}\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context.Summation}\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context.WaitEntity}\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          ;; % chktex 26
          $op$ : ::= % chktex 26
          | $\texttt{==}$ : or $\texttt{=}$ % chktex 26
          | $\texttt{<}$ : or ⊂ % chktex 26
          | $\texttt{<=}$ : or ⊆ % chktex 26
          | $\texttt{>}$ : or ⊃ % chktex 26
          | $\texttt{>=}$ : or ⊇ % chktex 26
          ;; % chktex 26
          Where \\ & \(C\) -> {is a string that specifies the color\\ of the node} : % chktex 26
          ;; % chktex 26
          \(S\) -> is a sets of entities : % chktex 26
          ;; % chktex 26
          \(x\) -> is a variable : % chktex 26
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for \(\texttt{NodeColor}\)}\label{bnf_node_color}
      \end{minipage}\vspace{1em}

      The \(\texttt{NodeColor}\) structure assigns the first correct color to the node. The structure can be thought of as a list of pairs; each pair has an entry that evaluated returns true or false, and an entry that holds the desired color of the node.
      To find the correct color, the list is scanned until the first pair that returns true and the color is assigned. If no pair returns true, a default value is assigned, specified after \(\texttt{!}\). The possible functions expressible by the grammar are the ones expressed by \(E\) and query either the entities available or the current context.

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },)
          $EdgeColor$ : ::= % chktex 26
          | $\texttt{!} \texttt{"}\ C\ \texttt{"}$ : % chktex 26 chktex 18
          | $E\ \texttt{\textbar}\texttt{\textbar}\ EdgeColor$ : % chktex 26
          ;; % chktex 26
          $E$ : ::= % chktex 26
          | $\texttt{Entities}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Context}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{T}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Reactants}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{AbsentReactants}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Inhibitors}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{PresentInhibitors}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          | $\texttt{Products}\ \mathit{op}\ S\ \texttt{?} \texttt{"}C\texttt{"}$ : % chktex 26 chktex 18
          ;; % chktex 26
          $op$ : ::= % chktex 26
          | $\texttt{==}$ : or $\texttt{=}$ % chktex 26
          | $\texttt{<}$ : or ⊂ % chktex 26
          | $\texttt{<=}$ : or ⊆ % chktex 26
          | $\texttt{>}$ : or ⊃ % chktex 26
          | $\texttt{>=}$ : or ⊇ % chktex 26
          ;; % chktex 26
          Where \\ & \(C\) -> {is a string that specifies the color\\ of the node} : % chktex 26
          ;; % chktex 26
          \(S\) -> is a sets of entities : % chktex 26
          ;; % chktex 26
          \(x\) -> is a variable : % chktex 26
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for \(\texttt{EdgeColor}\)}\label{bnf_edge_color}
      \end{minipage}\vspace{1em}


      \(\texttt{EdgeColor}\) behaves in a similar manner as \(\texttt{NodeColor}\), except the base structure is a \(\texttt{Label}\), so every field is a \(\texttt{Set}\).
    \end{subsection}

    \begin{subsection}{Slicing Trace}\label{design_trace}
      Only one structure for slicing trace is provided, but is made to work with both RS and Positive RS with generics. The only method they have is \(\texttt{slice}(\mathit{trace}, \mathit{marking}: \texttt{set}) \to \texttt{trace}^{?}\) which returns, if successful, a new sliced trace.
    \end{subsection}

    \begin{subsection}{Bisimilarity and Bisimulation}\label{bisimilarity_design}
      In the workspace \(\texttt{bisimilarity}\) the algorithms by Kanellakis and Smolka, and Paige and Tarjan are implemented over generic graphs. Instead of an implementation over graphs with generic parameters, the input have to implement generic traits from the \(\texttt{petgraph}\) library, making it possible to use with different types of graph, for example spare graphs or matrix graphs.

      One key feature was the ability to control via a domain specific language the labels on the edges of the graphs. The developed language is able to also specify values over nodes such that nodes with equal value may be collapsed into one node with outgoing and incoming edges inherited from the original nodes. The code for the typechecking and execution is available in the library \(\texttt{assert}\).

      The language has way to define subroutines or functions, has no while loop and limited for loop construction, so that the execution always terminates.

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },
          comment = {==})
          $Assert$ == ::= % chktex 26
          | $\texttt{label} \texttt{\{} Tree \texttt{\}}$ == {$\texttt{label}$ is replaced by other\\ strings to differentiate\\ languages}
          ;; % chktex 26

          $Tree$ == ::= % chktex 26
          | $Tree \texttt{;} Tree$ ==
          | $\texttt{if}\ E\ \texttt{then \{} Tree \texttt{\};} $ ==
          | {$\texttt{if}\ E\ \texttt{then \{} Tree \texttt{\}}$ \\ $\texttt{else \{} Tree \texttt{\};} $} ==
          | $\texttt{let}\ x\ \texttt{=}\ E \texttt{;}$ ==
          | $\texttt{let}\ x \texttt{.} Qualifier\ \texttt{=}\ E \texttt{;}$ ==
          | $\texttt{return}\ E \texttt{;}$ ==
          | $\texttt{for}\ x\ \texttt{in}\ Range\ \texttt{\{} Tree \texttt{\};}$ ==
          ;; % chktex 26

          $E$ == ::= % chktex 26
          | $unaryP \texttt{(} E \texttt{)}$ == % chktex 9
          | $E \texttt{.} unaryS $ ==
          | $\texttt{(} E\ binary\ E \texttt{)}$ == % chktex 9
          | $binaryP \texttt{(} E \texttt{,} E \texttt{)}$ == % chktex 9
          | $Term$ ==
          ;; % chktex 26

          $Term$ == ::= % chktex 26
          | $\texttt{true}$ ==
          | $\texttt{false}$ ==
          | $x$ ==
          | $i$ ==
          | $l$ ==
          | $set$ ==
          | $\texttt{'} s \texttt{'}$ == element
          | $\texttt{"} s \texttt{"}$ == string % chktex 18
          | $\texttt{(} E \texttt{)}$ == % chktex 9
          ;; % chktex 26

          $Range$ == ::= % chktex 26
          | $\texttt{\{} E \texttt{\}}$ == iterate over set
          | $\texttt{\{} E \texttt{..} E \texttt{\}}$ == iterate over integer range
          ;; % chktex 26
          Where \\ & \(S\) -> is a sets of entities, see\ \ref{bnf_set} ==
          ;; % chktex 26
          \(i\) :in: $\mathbb{Z}$ == % chktex 26
          ;; % chktex 26
          \(x\) -> is a variable name ==
          ;; % chktex 26
          \(l\) -> is a label, see\ \ref{bnf_set} ==
          ;; % chktex 26
          \(set\) -> is a set, see\ \ref{bnf_set} ==
          ;; % chktex 26
          \(s\) -> is a string ==
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for \(\texttt{Assert}\)}\label{bnf_assert}
      \end{minipage}\vspace{1em}

      Continues on the next page.

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },
          comment = {==})
          $unaryP$ == ::= % chktex 26
          | $\texttt{empty}$ ==
          | $\texttt{length}$ ==
          | $\texttt{tostr}$ ==
          | $\texttt{toel}$ == string to element
          | $\texttt{Entities}$ ==
          | $\texttt{Context}$ ==
          | $\texttt{Reactants}$ ==
          | $\texttt{ReactantsAbsent}$ ==
          | $\texttt{Inhibitors}$ ==
          | $\texttt{InhibitorsPresent}$ ==
          | $\texttt{Products}$ ==
          | $\texttt{AvailableEntities}$ ==
          | $\texttt{AllReactants}$ ==
          | $\texttt{AllInhibitors}$ ==
          | $\texttt{SystemEntities}$ ==
          | $\texttt{SystemContext}$ ==
          | $\texttt{source}$ == source of edge
          | $\texttt{target}$ == target of edge
          | $\texttt{label}$ == label of an edge
          | $\texttt{neighbours}$ == node's neighbours
          | $\texttt{system}$ == node's system
          ;; % chktex 26

          $binary$ == ::= % chktex 26
          | $\texttt{\&\&}$ == logical and, set intersection
          | $\texttt{\textbar\textbar}$ == logical or, set union
          | $\texttt{\^{}\^{}}$ == logical xor, set xor
          | $\texttt{<}$ == less, set inclusion
          | $\texttt{<=}$ == less equal, set inclusion or equal
          | $\texttt{>}$ == greater, reverse set inclusion
          | $\texttt{>=}$ == {greater equal,\\reverse set inclusion or equal}
          | $\texttt{=}\texttt{=}$ ==
          | $\texttt{!=}$ ==
          | $\texttt{+}$ ==
          | $\texttt{*}$ ==
          | $\texttt{\^{}}$ ==
          | $\texttt{/}$ == quotient
          | $\texttt{\%}$ == reminder
          | $\texttt{::}$ == concatenation
          ;; % chktex 26

          $binaryP$ == ::= % chktex 26
          | $\texttt{substr}$ ==
          | $\texttt{min}$ == % chktex 35
          | $\texttt{max}$ == % chktex 35
          | $\texttt{commonsubstr}$ ==
          ;; % chktex 26

          $unaryS$ == ::= % chktex 26
          | $\texttt{Entities}$ ==
          | $\texttt{length}$ ==
          | $\texttt{tostr}$ ==
          | $\texttt{toel}$ ==
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \ContinuedFloat{}
        \caption{Syntax for \(\texttt{Assert}\) (Continued)}
      \end{minipage}\vspace{1em}

      Four different languages are provided as modules in the workspace \(\texttt{Assert}\):
      \begin{itemize}
      \item \(\texttt{relabel}\)
      \item \(\texttt{grouping}\)
      \item \(\texttt{positive\_relabel}\)
      \item \(\texttt{positive\_grouping}\)
      \end{itemize}

      \(\texttt{relabel}\) has, in its syntax, the first token equal to \(\texttt{label}\), has as special variables \(\texttt{label}\) and \(\texttt{edge}\) that function as input, with \(\texttt{edge.label} == \texttt{label}\). It's used for grouping labels before calculating bisimilarity. \(\texttt{grouping}\) has, in its syntax, the first token equal to \(\texttt{node}\), has as special variables \(\texttt{entities}\) and \(\texttt{node}\) that function as input, with \(\texttt{node.system.SystemEntities} == \texttt{entities}\). It's used for grouping nodes. \(\texttt{positive\_relabel}\) and \(\texttt{positive\_grouping}\) have as first token \(\texttt{label}\) and \(\texttt{node}\) respectively and behave in a similar manner compared to their respective functions over RS.%

      The template language requires two structures to function relating to the input of the language: a type structure and a value structure. The trait \(\texttt{SpecialVariables}\) holds all the necessary functions that need to be implemented for the special variables to function. Finally the generic language can have the two functions \(\texttt{typecheck}\) and \(\texttt{execute}\) implemented.

      The language is very limited and is only designed for simple algorithms since there is no scoping. Typechecking consists in only asserting acceptable types for unary and binary functions, range declaration and for all return statements to return the same type.

      A version for Positive RS is also provided and reflects the previous grammar with basic types replaced with their positive versions.
    \end{subsection}

    \begin{subsection}{Grammar and Separated Grammar}
      Two workspaces are provided for parsing the structures above. \(\texttt{Grammar}\) creates only one endpoint that parses a system and a list of instructions. Those instructions are then executed via the library \(\texttt{execution}\). A simple CLI has been implemented in the workspace \(\texttt{analysis}\), with proper error formatting for LALRPOP errors.
    \end{subsection}

    \begin{subsection}{Experiments and Frequency}\label{experiment}
      An experiment is a list of weights and a list of sets of same length. The sets are used as entities given in addition to the context entities when computing the RS.\ The resulting trace is then synthesized into relative frequencies. The methods offered by \(\texttt{Frequency}\) and \(\texttt{PositiveFrequency}\) are:

      \begin{itemize}
      \item \(\texttt{naive\_frequency}(sys: \texttt{system}) \to \texttt{frequency}^{?}\), which computes the relative frequency of each entity in all traversed states, assuming the computation is finite;\label{function_naive_frequency}
      \item \(\texttt{loop\_frequency}(sys: \texttt{system}, symbol: \texttt{IdType}) \to \texttt{frequency}\), which computes the relative frequency of each entity in each state of the encountered loop, assuming the system stabilizes in a loop;
      \item \(\texttt{limit\_frequency}(experiment: \texttt{[set]}, reactions: \texttt{[reaction]}, entities: \texttt{set}) \to \texttt{frequency}^{?}\), which computes the relative frequency of each entity in the states of the last loop by providing repeatedly the sets in the experiment until the system stabilizes in a loop;
      \item \(\texttt{fast\_frequency}(experiment: \texttt{[set]}, reactions: \texttt{[reaction]}, entities: \texttt{set},\\ weights: \texttt{[int]}) \to \texttt{frequency}^{?}\), which computes the weighted relative frequency of each entity in any of the loops.
      \end{itemize}

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },
          comment = {==})
          $Experiment$ == ::= % chktex 26
          | $\texttt{Weights : } W \texttt{ Sets : } S$ ==
          ;; % chktex 26
          $W$ == ::= % chktex 26
          | $ i \texttt{, } W $ ==
          | $ i $ ==
          | $ \epsilon $ ==
          ;; % chktex 26
          $S$ == ::= % chktex 26
          | $ s \texttt{, } S $ ==
          | $ s $ ==
          | $ \epsilon $ ==
          ;; % chktex 26
          Where \\ & \(s\) -> is a sets of entities, see\ \ref{bnf_set} ==
          ;; % chktex 26
          \(i\) :in: $\mathbb{Z}$ == % chktex 26
          ;; % chktex 26
          \(\epsilon\) -> is the empty string == % chktex 26
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for Experiment}
      \end{minipage}
    \end{subsection}

    \begin{subsection}{Instructions}
      The command line interface provided by the workspace \(\texttt{analysis}\) expects as input a path to a file with a RS and some instructions, reads the file, executes the instructions and returns the result in the forms specified. The syntax for specifying instructions is as follows:\vspace{1em}

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },
          comment = {==})
          $Instructions$ == ::= % chktex 26
          | $System\ \mathit{Is}$ ==
          | $\texttt{Deserialize (} path \texttt{) } \mathit{Is}$ == % chktex 9
          ;; % chktex 26

          $\mathit{Is}$ == ::= % chktex 26
          | $ I, \mathit{Is} $ ==
          | $ I $ ==
          | $ \epsilon $ ==
          ;; % chktex 26

          Where \\ & \(\epsilon\) -> is the empty string ==
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \caption{Syntax for Instructions}
      \end{minipage}

      \begin{minipage}{\textwidth}
        \begin{bnf}(relation-sym-map = % chktex 36
          {
            {::=} = {\ensuremath{\Coloneqq}},
            {->} = {},
            {:in:} = {\ensuremath{\in}},
          },
          comment = {==})

          $I$ == ::= % chktex 26
          | $ \texttt{Stats > } so $ ==
          | $ \texttt{Target > } so $ ==
          | $ \texttt{Target ( Limit :} i \texttt{ ) > } so $ == % chktex 9
          | $ \texttt{Run > } so $ ==
          | $ \texttt{Run ( Limit :} i \texttt{ ) > } so $ == % chktex 9
          | $ \texttt{Loop (} el \texttt{) > } so $ == % chktex 9
          | $ \texttt{Frequency > } so $ ==
          | $ \texttt{LimitFrequency ("} path \texttt{") > } so $ == % chktex 9 chktex 18
          | $ \texttt{FastFrequency ("} path \texttt{") > } so $ == % chktex 9 chktex 18
          | $ \texttt{Digraph > } gso $ ==
          | $ \texttt{Digraph } group \texttt{ > } \mathit{gso} $ ==
          | $ \texttt{Bisimilarity ("} path \texttt{") relabel } relabel \texttt{ > } so $ == % chktex 9 chktex 18
          ;; % chktex 26

          $\mathit{gso}$ == ::= % chktex 26
          | $g\ \texttt{\textbar}\ \mathit{gso}$ ==
          | $g$ ==
          ;; % chktex 26

          $g$ == ::= % chktex 26
          | { $\texttt{Dot}$\\ $\texttt{\textbar}\ NodeDisplay$\\ $\texttt{\textbar}\ EdgeDisplay$\\ $\texttt{\textbar}\ NodeColor$\\ $\texttt{\textbar}\ EdgeColor$\\ $\texttt{>}\ so$ } ==
          | { $\texttt{GraphML}$\\ $\texttt{\textbar}\ NodeDisplay$\\ $\texttt{\textbar}\ EdgeDisplay$\\ $\texttt{>}\ so$ } ==
          | $\texttt{Serialize("} path \texttt{")}$ == % chktex 9 chktex 18
          ;; % chktex 26

          $so$ == ::= % chktex 26
          | $\texttt{Print}; so$ ==
          | $\texttt{Print}$ ==
          | $\texttt{Save ("} path \texttt{")}; so$ == % chktex 9 chktex 18
          | $\texttt{Save ("} path \texttt{")}$ == % chktex 9 chktex 18
          ;; % chktex 26

          Where \\ & \(path\) -> is a path to a file ==
          ;; % chktex 26
          \(NodeDisplay\) -> follows the syntax from\ \ref{bnf_node_display} ==
          ;; % chktex 26
          \(EdgeDisplay\) -> follows the syntax from\ \ref{bnf_edge_display} ==
          ;; % chktex 26
          \(NodeColor\) -> follows the syntax from\ \ref{bnf_node_color} ==
          ;; % chktex 26
          \(EdgeColor\) -> follows the syntax from\ \ref{bnf_edge_color} ==
          ;; % chktex 26
          \(group\) -> is a group function with syntax from\ \ref{bnf_assert} ==
          ;; % chktex 26
          \(relabel\) -> is a relabel function with syntax from\ \ref{bnf_assert} ==
          ;; % chktex 26
          \(i\) :in: $\mathbb{N}$ == % chktex 26
          ;; % chktex 26
          \(el\) -> is a string that symbolizes an element ==
          ;; % chktex 26
          \(path\) -> is a path to a file ==
          ;; % chktex 26
        \end{bnf}
        \captionsetup{type=table, name=\textbf{Syntax}}
        \ContinuedFloat{}
        \caption{Syntax for Instructions (Continued)}
      \end{minipage}

      The instruction \(\texttt{Stats}\) returns static information and statistics about the system. \(\texttt{Target}\) and \(\texttt{Run}\) return the results of the function with the same name defined in section\ \ref{function_target}. \(\texttt{Loop}\) returns the result of the function \(\texttt{lollipops\_only\_loop\_named}\) described in the same section. \(\texttt{Frequency}\) returns the results of \(\texttt{naive\_frequency}\) as described in section\ \ref{function_naive_frequency}. \(\texttt{LimitFrequency}\) and \(\texttt{FastFrequency}\) require a path to an experiment, with syntax described in\ \ref{experiment}, and they return the result of \(\texttt{limit\_frequency}\) and \(\texttt{fast\_frequency}\) respectively. \(\texttt{Digraph}\) may take a function \(group\) that groups together nodes that have the same output, described in section\ \ref{bisimilarity_design}. The graphs can be either saved as a Dot or GraphML file or serialized directly. \(\texttt{Bisimilarity}\) takes a path to another instruction file, whose instructions are ignored, and returns if the two systems are bisimilar. The results can be saved to a file or print to screen or both.
    \end{subsection}
  \end{section}

  \begin{section}{ReactionSystemsGUI}
    During development of ReactionSystems, a need for a more intuitive interaction with the structures presented itself. Since all the operations on the types where already limited and
    structured, a visual programming language was chosen as the best fit.

    The library {\(\texttt{egui\_node\_graph2}\)}\cite{egui_node_graph22024} was chosen since it offered customizability, performance and ease of programming. The library unfortunately lacked compatibility with the most recent version of {\(\texttt{egui}\)}\cite{Ernerfeldt2025}, so it is included as a workspace and modified to fit better the need of the project.
    This way a couple of visual bugs present in the original code have also been fixed.

    \(\texttt{egui\_node\_graph2}\) is based on the library \(\texttt{egui}\), which is an immediate mode GUI. % chktex 13
    It differentiate itself from retained mode GUIs by having all the elements specified at every frame; this eases programming at the expense of performance. The trade-off is favorable since most of the computation will be on the algorithms over RS and the number of elements of the UI will remain small in most cases.

    All the functions previously described are available as ``nodes'' in the GUI program. Each takes one or more inputs, colored by type, and prevents wrong types from connecting, reducing user error when connecting similarly colored types.

    Since at every step all of the GUI is recalculated, a robust cache structure is needed.
    The cache developed keeps track of the modified nodes and only recomputes if necessary, exploiting the structure of the graph.

    The library \(\texttt{egui\_node\_graph2}\) was also chosen for its ability to create a web application directly from Rust code. The web application is limited; there is no interaction with the file system and no true multi-threading. These limitations are imposed by WebAssembly itself, not by the transpilation from Rust.

    The native application executes the expressed instructions in a separate thread and returns the result to the GUI thread to be displayed. Thus the web application may ``freeze'' and become unresponsive with long calculations.

    Both native and web applications have the ability to save the current state and resume. The saved state is stored in the browser cache in the web application and in special directories in the native one:
    \begin{itemize}
    \item Linux: \(\texttt{/home/UserName/.local/share/Reaction-Systems}\)
    \item macOS:\ \(\texttt{/Users/UserName/Library/Application Support/Reaction-Systems}\)
    \item Windows: \(\texttt{C:\textbackslash{}Users\textbackslash{}UserName\textbackslash{}AppData\textbackslash{}Roaming\textbackslash{}Reaction-Systems\textbackslash{}data}\)
    \end{itemize}

    The native application also has the ability to save and load the state from a file. The files have by default the extension ``\(\texttt{.ron}\)''. The web version has no ability to interact with the file system due to a limitation of WebAssembly.

    \begin{figure}
      \centering
      \begin{bytefield}[endianness=little, bitwidth=0.3em]{64}
        \bitheader{0, 8, 16, 24, 32, 40, 48, 56, 63} \\
        \bitbox{64}[bgcolor=lightgreen]{Version Number} \\
        \begin{rightwordgroup}{Size}
          \bitbox{64}[bgcolor=lightgreen]{State Length} \\
          \bitbox{64}[bgcolor=lightgreen]{Translator Length} \\
          \bitbox{64}[bgcolor=lightgreen]{Cache Length}
        \end{rightwordgroup} \\

        \wordbox{2}{State} \\
        \wordbox{2}{Translator} \\
        \wordbox{2}{Cache} \\
      \end{bytefield}
      \caption{Save file structure}\label{save_file_structure}
    \end{figure}

    The file structure can be seen in figure\ \ref{save_file_structure}, where ``state'' refers to the state of the GUI, ``translator'' refers to the \(\texttt{Translator}\) structure used to encode entities names into fixed sized integers, and ``cache'' refers to the cache structure for the GUI.\ Version number is a little-endian \(\texttt{u64}\) that encodes the version number of the application; if different from the version of the application, a warning will be issued, but the application will try and load the state anyway. Each ``length'' field is a little-endian \(\texttt{u64}\) and indicates the length in bytes of the corresponding field.

    The user can request the result of a computation by interacting with the button ``\textit{Set active}'' under most of the windows. A panel on the right of the screen appears with the computed result. The nodes ``Save string to file'', ``Save SVG'' and ``Save Rasterized SVG''  instead have a button ``\textit{Write}'' that writes to file the result. The node ``Read a file'' has an extra button ``\textit{Update file}'' that reads again the file from disk since a filewatcher has not been implemented.

    Since the generated graphs were often times immediately converted to DOT files and rendered to SVG, a native renderer is included that can create PNG images of the supplied graph. They are then rendered to screen. This reduces greatly the time switching between software to achieve the same result.

    \begin{table}
      \centering
      \fboxrule=0.25mm
      \begin{tblr}{colspec={Q[c, m]Q[c, l]Q[c, l]}, colsep=3pt}
        \fcolorbox{black}{color_Error}{\makebox[2mm][l]{\strut}} & \(\texttt{Error}\) & Structure that holds error messages \\

        \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \(\texttt{String}\) & A string \\
        \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}} & \(\texttt{Path}\) & A path to a file \\
        \fcolorbox{black}{color_Svg}{\makebox[2mm][l]{\strut}} & \(\texttt{Svg}\) & A structure for creating and rendering SVG \\
        \fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveInt}\) & Integer in \(\mathbb{N}\) \\
        \fcolorbox{black}{color_Symbol}{\makebox[2mm][l]{\strut}} & \(\texttt{Symbol}\) & A single symbol, see section\ \ref{design_entities} \\

        \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \(\texttt{System}\) & see section\ \ref{design_system} \\
        \fcolorbox{black}{color_Environment}{\makebox[2mm][l]{\strut}} & \(\texttt{Environment}\) & see section\ \ref{design_environment} \\
        \fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \(\texttt{Set}\) & see section\ \ref{design_set} \\
        \fcolorbox{black}{color_Context}{\makebox[2mm][l]{\strut}} & \(\texttt{Context}\) & see section\ \ref{design_process} \\
        \fcolorbox{black}{color_Reactions}{\makebox[2mm][l]{\strut}} & \(\texttt{Reactions}\) & see section\ \ref{design_reaction} \\

        \fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & \(\texttt{Experiment}\) & see section\ \ref{experiment} \\

        \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveSystem}\) & see section\ \ref{design_system} \\
        \fcolorbox{black}{color_PositiveEnvironment}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveEnvironment}\) & see section\ \ref{design_environment} \\
        \fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveSet}\) & see section\ \ref{design_set} \\
        \fcolorbox{black}{color_PositiveContext}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveContext}\) & see section\ \ref{design_process} \\
        \fcolorbox{black}{color_PositiveReactions}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveReactions}\) & see section\ \ref{design_reaction} \\

        \fcolorbox{black}{color_Trace}{\makebox[2mm][l]{\strut}} & \(\texttt{Trace}\) & see section\ \ref{design_trace} \\
        \fcolorbox{black}{color_PositiveTrace}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveTrace}\) & see section\ \ref{design_trace} \\

        \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}} & \(\texttt{Graph}\) & see section\ \ref{design_graph} \\
        \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveGraph}\) & see section\ \ref{design_graph} \\

        \fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}} & \(\texttt{DisplayNode}\) & see section\ \ref{design_graph} \\
        \fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}} & \(\texttt{DisplayEdge}\) & see section\ \ref{design_graph} \\
        \fcolorbox{black}{color_ColorNode}{\makebox[2mm][l]{\strut}} & \(\texttt{ColorNode}\) & see section\ \ref{design_graph} \\
        \fcolorbox{black}{color_ColorEdge}{\makebox[2mm][l]{\strut}} & \(\texttt{ColorEdge}\) & see section\ \ref{design_graph} \\

        \fcolorbox{black}{color_AssertFunction}{\makebox[2mm][l]{\strut}} & \(\texttt{AssertFunction}\) & see section\ \ref{bisimilarity_design} \\
        \fcolorbox{black}{color_GroupFunction}{\makebox[2mm][l]{\strut}} & \(\texttt{GroupFunction}\) & see section\ \ref{bisimilarity_design} \\
        \fcolorbox{black}{color_PositiveAssertFunction}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveAssertFunction}\) & see section\ \ref{bisimilarity_design} \\
        \fcolorbox{black}{color_PositiveGroupFunction}{\makebox[2mm][l]{\strut}} & \(\texttt{PositiveGroupFunction}\) & see section\ \ref{bisimilarity_design} \\
      \end{tblr}
      \caption{Types in ReactionSystemsGUI with associated color.}\label{types_gui}
    \end{table}

    \fboxrule=0.25mm
    \begin{longtblr}[
      caption={Available nodes in ReactionSystemsGUI with inputs and outputs in color.},
      label={node_in_out},
      ]{
      colspec={Q[b, r]|Q[c, m]|Q[c, m]|Q[b, l]},
      colsep=2pt,}
      \(\texttt{String}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & Creates a string \\
      \(\texttt{Path}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}} & Creates a path from a string \\
      \(\texttt{Read file}\) & \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & Reads a file into a string \\
      \(\texttt{Save string to file}\) & \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & & Save a string to a file \\
      \(\texttt{Symbol}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Symbol}{\makebox[2mm][l]{\strut}} & Creates a symbol from a string \\
      \(\texttt{Sleep}\) & \fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & Waits for selected number of seconds \\
      \(\texttt{Dot file to SVG}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Svg}{\makebox[2mm][l]{\strut}} & Parses a Dot file string into an SVG \\
      \(\texttt{Save SVG}\) & \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Svg}{\makebox[2mm][l]{\strut}} & & Saves an SVG \\
      \(\texttt{Save Rasterized SVG}\) & \fcolorbox{black}{color_Path}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Svg}{\makebox[2mm][l]{\strut}} & & Saves an SVG as a picture \\

      \(\texttt{Create System}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & Creates system from string \\
      \(\texttt{Create Positive System}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & Creates positive system from system \\
      \(\texttt{Compose System}\) & \fcolorbox{black}{color_Environment}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Context}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Reactions}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & {Composes system from\\individual structures} \\
      \(\texttt{Compose Positive System}\) & \fcolorbox{black}{color_PositiveEnvironment}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveContext}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveReactions}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Decompose System}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Environment}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Context}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Reactions}{\makebox[2mm][l]{\strut}} & {Decomposes system\\into individual structures} \\
      \(\texttt{Decompose Positive System}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveEnvironment}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveContext}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveReactions}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Environment}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Environment}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Environment}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveEnvironment}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Set}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Set}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Context}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Context}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Context}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveContext}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Reactions}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Reactions}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Reactions}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveReactions}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Convert to Positive Environment}\) & \fcolorbox{black}{color_Environment}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveEnvironment}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Convert to Positive Set}\) & \fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Convert to Positive Context}\) & \fcolorbox{black}{color_Context}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveContext}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Convert to Positive Reactions}\) & \fcolorbox{black}{color_Reactions}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveReactions}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Statistics}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Target}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Target of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Run}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Run of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} &  \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Loop}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Symbol}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & {Applies function\\\(\texttt{lollipops\_only\_loop\_named}\) to RS} \\
      \(\texttt{Loop of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Symbol}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Create Experiment}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & Creates experiment from string \\

      \(\texttt{Frequency}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Frequency of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Limit Frequency}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Limit Frequency of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Fast Frequency}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Fast Frequency of Positive RS}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Experiment}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Graph System}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}} & Creates digraph of RS \\
      \(\texttt{Graph Positive System}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Create Dot file}\) & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_ColorNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_ColorEdge}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & Creates Dot file from a graph \\
      {\(\texttt{Create Dot file}\)\\\(\texttt{of Positive System}\)} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_ColorNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_ColorEdge}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Create GraphML file}\) & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & Creates GraphML file from a graph \\
      {\(\texttt{Create GraphML file}\)\\\(\texttt{of Positive System}\)} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Display node function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_DisplayNode}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Display edge function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_DisplayEdge}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Color node function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_ColorNode}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Color edge function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_ColorEdge}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Bisimilarity Kanellakis \& Smolka}\) & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_AssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Bisimilarity Kanellakis \& Smolka}\)\\\(\texttt{for Positive RS}\)} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveAssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Bisimilarity Paige \& Tarjan}\) & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_AssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Bisimilarity Paige \& Torjan}\)\\\(\texttt{for Positive RS}\)} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveAssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Bisimilarity Paige \& Tarjan}\)\\\(\texttt{(ignore labels)}\)} & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_AssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Bisimilarity Paige \& Torjan}\)\\\(\texttt{(ignore labels) for Positive RS}\)} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveAssertFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Create relabeling edge function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_AssertFunction}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Create relabeling edge function}\)\\\(\texttt{for Positive RS}\)} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveAssertFunction}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Trace}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Trace}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Trace}\) & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveInt}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveTrace}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Slice Trace}\) & \fcolorbox{black}{color_Trace}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Trace}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive Slice Trace}\) & \fcolorbox{black}{color_PositiveTrace}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveTrace}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Trace to string}\) & \fcolorbox{black}{color_Trace}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Positive trace to string}\) & \fcolorbox{black}{color_PositiveTrace}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Overwrite context entities}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Overwirite reaction entities}\) & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_Set}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_System}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Overwrite context entities}\)\\\(\texttt{of Positive System}\)} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Overwrite reaction entities}\)\\\(\texttt{of Positive System}\)} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveSet}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveSystem}{\makebox[2mm][l]{\strut}} & \\

      \(\texttt{Create Grouping Function}\) & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_GroupFunction}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Group Nodes}\) & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_GroupFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_Graph}{\makebox[2mm][l]{\strut}} & \\
      {\(\texttt{Create Grouping Function}\)\\\(\texttt{for Positive System}\)} & \fcolorbox{black}{color_String}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveGroupFunction}{\makebox[2mm][l]{\strut}} & \\
      \(\texttt{Group Nodes of Positive System}\) & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}}\fcolorbox{black}{color_PositiveGroupFunction}{\makebox[2mm][l]{\strut}} & \fcolorbox{black}{color_PositiveGraph}{\makebox[2mm][l]{\strut}} & \\
    \end{longtblr}

    All the types can be seen in table\ \ref{types_gui} that are used for the node's input and output. Each type has a distinct color associated that is used to color the connectors between nodes. All nodes can be seen in table\ \ref{node_in_out}. The second column holds the color of the inputs types used; the third column holds the color of the outputs types.

  \end{section}
\end{chapter}
